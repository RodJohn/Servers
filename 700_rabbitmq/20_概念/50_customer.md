订阅
1. 消费者通过AMQP的basic.consume命令订阅,
这样做会将信道置为接收模式,订阅消息后,消息一到达队列时就自动接收,直到取消队列的订阅为止
2. 消费者通过AMQP的basic.get命令订阅,
这样做会将信道置为接收模式,订阅消息后,获得单条消息后,然后自动取消订阅,
千万不要妄想放在循环里代替basic.consume,否则无法发挥其高吞吐量特性
3. 如果消息到达了无人订阅的队列,
消息会在队列中等待,一旦有消费者订阅该队列,队列的消息会发送给消费者


多消费者
当一个队列拥有多个消费者时，队列接收到的消息将以循环（round-robin）的方式发给消费者。
最终每条信息只会发送给一个订阅的消费者。


ACK
消费者接收的每一条信息都必须进行确认，
可以使用basic.ack命令显式确认或在订阅队列时将auto_ack参数设置为true（一旦接收就自动确认）。
一旦消息被确认,RabbitMQ才会安全的把消息从队列中删除,
主要是防止确认之前RabbitMQ断开连接或取消订阅或程序崩溃,RabbitMQ会认为这条消息没有分发,然后重新分发给下一个订阅的消费者,RabbitMQ会认为没有确认的消费者并没有准备好接收下一条消息,所以可以好好利用这一点,如果处理消息内容非常耗时,则你的应用程序可以延迟确认消息,直到消息处理完成再确认,这样可防止RabbitMQ持续不断的消息导致过载

没有任何消息超时限制；只有当消费者挂掉时，RabbitMQ才会重新投递。即使处理一条消息会花费很长的时间。


REJECT

 如果收到消息后想要明确拒绝而不是确认收到消息的话,可使用AMQP的basic.reject,当把其basic.reject参数设置为true时,RabbitMQ会将消息重新发送给下一个订阅的消费者,如果设置为false,则RabbitMQ会把消息从队列中移除,而不会把它发送给新的消费者,当然也可以通过对消息确认的方式来简单地忽略该消息,如当你检测到一条格式错误的消息而任何一个消费者都无法处理的时候,此时就非常有用了.